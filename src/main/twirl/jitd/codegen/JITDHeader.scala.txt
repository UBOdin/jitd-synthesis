@import jitd.codegen._
@import jitd.spec._
@(ctx:Render)

///////////////////// Headers ///////////////////// 

#include <iostream>
#include <vector>
#include <unordered_map>
#include <set>
#include <unordered_set>
#include <queue>
#include <memory>
#include <atomic>
#include <algorithm>
#include <ios>
#include <functional>
#include <sys/time.h>
#include <pthread.h>
#include "tbb/concurrent_queue.h" 
#include <condition_variable>
#include<mutex>
#include<cassert>
@for(include <- ctx.definition.includes) { 
#include "@include"
}
@if(ctx.debug){
  #define JITD_DEBUG(cmd) std::cerr << cmd;
} else {
  #define JITD_DEBUG(cmd)
}
#define assertm(exp, msg) assert(((void)msg, exp))
///////////////////// Structures ///////////////////// 

@ctx.structTypedefs

///////////////////// Base Node Meta ///////////////////// 
typedef enum{
 @for( mutator <- ctx.definition.mutators ) {
      FLAG_@mutator.name,
    }
    EXIT
}ClientInstruction;


typedef enum { 
  @for(node <- ctx.definition.nodes) {
    @node.enumName, 
  }
} JITDNodeType;

class JITDNode {
  public: 
  JITDNode(JITDNodeType type) : type(type) {}

  JITDNodeType type;
  @{ctx.policyImplementation.state(ctx)}
};

typedef std::function<void(std::shared_ptr<JITDNode> &new_node)> UpdateHandle;

struct mutatorCqElement{
  int flag;
  std::pair<std::shared_ptr<std::shared_ptr<JITDNode>>,std::shared_ptr<std::shared_ptr<JITDNode>>> element;
  mutatorCqElement(){}
  mutatorCqElement(const int &op,const std::shared_ptr<std::shared_ptr<JITDNode>> &old_ptr,const std::shared_ptr<std::shared_ptr<JITDNode>> &new_ptr):flag(op),element(std::pair<std::shared_ptr<std::shared_ptr<JITDNode>>,std::shared_ptr<std::shared_ptr<JITDNode>>>(old_ptr,new_ptr)){}

};
///////////////////// Node Type Definitions ///////////////////// 

@for(node <- ctx.definition.nodes){
class @{node.renderName} : public JITDNode { 
  public:
  @{node.renderName}( @{ node.fields.map { ctx.fieldDefn(_, passByRef=true, isConst=true) }.mkString(", " )} ) : 
    JITDNode(@{node.enumName})
    @for(field <- node.fields){,
      @{field.name}(@{field.name})
    }
  {}
  @for(constructor <- node.constructors ){
    @{node.renderName}(@{constructor.args.map{ ctx.fieldDefn(_, passByRef=true, isConst=true) }.mkString(", " )}):
      JITDNode(@{node.enumName})
        @{constructor.defaults.map{", "+ctx.expression(_)}.mkString("")}
        @{ctx.statement(constructor.body)}
  }
  @for(field <- node.fields.filter { _.t == TNodeRef() }){
    void update_@{field.name}_handle(std::shared_ptr<JITDNode> &new_value){
      @{field.name} = new_value;
    }
  }

  public: @for(field <- node.fields){ 
    @{ctx.fieldDefn(field)}; 
  }
};
}

///////////////////// Transform Definitions ///////////////////// 

typedef enum { 
  @for(transform <- ctx.definition.transforms) {
   @transform.enumName,
  }
} JITDTransformType;



///////////////////// JITD Debug Methods ///////////////////// 

class JITD;
std::shared_ptr<JITD> assemble_jitd(std::istream &in);
void print_JITD_node_structure(std::shared_ptr<JITDNode> node, const std::string &prefix);
void print_JITD_node_structure_viz(std::shared_ptr<JITDNode> node,std::shared_ptr<JITDNode> parent);
void jitd_get_depth(std::shared_ptr<JITDNode> node,int depth, int &maxdepth);
void print_time_vector_sum();
void print_search_time_vector_sum();
   
///////////////////// JITD Accessors ///////////////////// 

@for( accessor <- ctx.definition.accessors ) {
  @{RenderAccessor.declaration( accessor, ctx, prefix="jitd_accessor_" )};
}
///////////////////// JITD Definition ///////////////////// 


      
    






class JITD {
  
  public:
    pthread_mutex_t lock;



    @{RenderPattern.ComparatorClass(ctx,ctx.policy.rule);}


    /*@{RenderPattern.SetPqDeclare(ctx,ctx.policy.rule,true);}*/
    @{RenderPattern.ViewDeclare(ctx,ctx.policy.rule,true);}

    std::unordered_multimap<std::shared_ptr<JITDNode> *,std::shared_ptr<JITDNode> *> childParentMap;
    tbb::concurrent_bounded_queue<mutatorCqElement> work_queue;


    JITD(std::shared_ptr<std::shared_ptr<JITDNode>> jitd_root) : jitd_root(jitd_root)
    {
      if (pthread_mutex_init(&lock, NULL) != 0) { 
        std::cerr<<"\n mutex init has failed\n"<<std::endl; 
        exit(-1);
      }
      this->work_queue.set_capacity(3000);
      @ctx.policyImplementation.init(ctx,ctx.policy.rule,"(*(this->jitd_root))")
    }
    


    @for(transform <- ctx.definition.transforms){
    bool @{transform.name}(std::shared_ptr<JITDNode> * &targetHandleRef);
    }
    #ifdef TRANSFORM_COUNT
    @for(transform <- ctx.definition.transforms){
      int @{transform.name}_count =0;
    }
    #endif
    @for( accessor <- ctx.definition.accessors ) {
      @{RenderAccessor.declaration( accessor, ctx, root = true )} {
        return @RenderAccessor.renderCall( accessor, ctx, "*jitd_root", "jitd_accessor_" );
      }
    }

    @for( mutator <- ctx.definition.mutators ) {
      @{RenderMutator.declaration( mutator, ctx )}
    }
    
    
   
    void print_pq();
    void check_pq();
    void print_map();
    void check_view();
    void times_transforms_called();
    std::shared_ptr<JITDNode> * getParent(std::shared_ptr<JITDNode> * &target);
    void SetPqErase(std::shared_ptr<JITDNode> * node_handle);
    void SetPqAdd(std::shared_ptr<JITDNode> * node_handle);
    void viewAdd(std::shared_ptr<JITDNode> * node_handle);
    void viewErase(std::shared_ptr<JITDNode> * node_handle);
    void fixMap(std::shared_ptr<JITDNode> * node_handle,std::shared_ptr<JITDNode> * parent);
    
    void print_debug() {print_JITD_node_structure(*jitd_root, std::string("")); }
    void get_depth(int depth,int &maxdepth) {jitd_get_depth(*jitd_root,depth,maxdepth);}
    void print_debug_viz() {print_JITD_node_structure_viz(*jitd_root,*jitd_root); }
    bool do_organize();
    int organize_wait();
    
    void check_pq_intergrity(){check_pq();};
    void print_pq_size() {print_pq();}

    
    @for(transform <- ctx.definition.transforms){
    long searchFor@{transform.name}(std::shared_ptr<JITDNode> * &targetHandleRef);}

    @for(transform <- ctx.definition.transforms){
    bool match@{transform.name}(std::shared_ptr<JITDNode> * &targetHandleRef);}

    //void initialize_struts(std::shared_ptr<JITDNode>* node, std::shared_ptr<JITDNode>* parent);
    void initialize_struts_view(std::shared_ptr<JITDNode>* node, std::shared_ptr<JITDNode>* parent);
    
    
  private:

    //std::shared_ptr<JITDNode> root;
    std::shared_ptr<std::shared_ptr<JITDNode>> jitd_root;
    
};


