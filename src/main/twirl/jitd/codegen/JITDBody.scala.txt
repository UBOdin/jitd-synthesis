@import jitd.codegen._
@import jitd.spec._
@import jitd.rewrite._
@import jitd.Debug
@(ctx:Render, headerFile:String)

#include <stack>
#include <sstream>
#include "runtime.hpp"
#include "@headerFile"
std::vector<float> time_vec_PushDownAndCrack;
std::vector<float> time_vec_CrackArray;
std::vector<float> time_vec_PushDownDontDeleteElemBtree;
std::vector<float> time_vec_PushDownDontDeleteElemConcat;
std::vector<float> time_vec_SortArray;
std::vector<float> time_vec_DeleteElemFromSortedArray;
std::vector<float> time_vec_MergeSortedBTrees;
std::vector<float> time_vec_MergeSortedConcat;
std::vector<float> time_vec_DeleteElemFromArray;
std::vector<float> search_time_vec_PushDownAndCrack;
std::vector<float> search_time_vec_CrackArray;
std::vector<float> search_time_vec_PushDownDontDeleteElemBtree;
std::vector<float> search_time_vec_PushDownDontDeleteElemConcat;
std::vector<float> search_time_vec_SortArray;
std::vector<float> search_time_vec_DeleteElemFromSortedArray;
std::vector<float> search_time_vec_MergeSortedBTrees;
std::vector<float> search_time_vec_MergeSortedConcat;
std::vector<float> search_time_vec_DeleteElemFromArray;

//#define JITD_DEBUG_POLICY true;
//std::shared_ptr<JITDNode> * rootHandleRef;


///////////////////// Transform Definitions ///////////////////// 

@for(transform <- ctx.definition.transforms){
@RenderFunction.body(ctx, TransformToFunction(ctx.definition, transform,"JITD::"),false)
}

///////////////////// Accessor Definitions ///////////////////// 

@for( accessor <- ctx.definition.accessors ) {
@{RenderFunction.body(ctx, AccessorToFunction(ctx.definition, accessor, "jitd_accessor_"),false)}
}

///////////////////// Mutator Definitions ///////////////////// 

@for( mutator <- ctx.definition.mutators ) {
@{RenderFunction.body(ctx, MutatorToFunction(ctx.definition, mutator, "JITD::"),false)}
@{RenderFunction.body(ctx, MutatorToFunctionAfter(ctx.definition, mutator, "JITD::after_"),true)}

}

///////////////////// Policy Implementation ///////////////////// 

@ctx.policyImplementation.utilityFunctions(ctx)
void JITD::process_cq(mutatorCqElement &pop_mce)
{
      if(pop_mce.flag == 0)
          {
            this->after_insert(pop_mce.element);
          }
      else if(pop_mce.flag == 1)
          {
            this->after_remove_elements(pop_mce.element);
          }
      else
          {
            std::cerr<<"Invalid Mutator Operation"<<std::endl;
            
          }
   
}
int JITD::organize_wait()
{
  
    int t = 0;
   
    bool not_done = true;
    while(true)
    {
      if(this->common_cq.empty() && not_done == true)
      {
        not_done = this->do_organize();
        t++;
      }
      else
      {
        mutatorCqElement pop_mce;
        this->common_cq.pop(pop_mce);
        if(pop_mce.flag == 2)
        {
          
          return t;
        }
        else
        {
          this->process_cq(pop_mce);
          not_done = true;
          
        }
      }
      
    
    }   
    
   
       
  return t;
}
int JITD::organize_process()
{
      
      bool not_done = true;
      int steps_taken = 0;
      
      while(not_done || !this->common_cq.empty())
      {
       
        mutatorCqElement pop_mce;
        bool popped = this->common_cq.try_pop(pop_mce);
        if(popped == true)
        {
          if(pop_mce.flag == 0)
          {
            this->after_insert(pop_mce.element);
          }
          else if(pop_mce.flag == 1)
          {
            this->after_remove_elements(pop_mce.element);
          }
          else
          {
            std::cerr<<"Invalid Mutator Operation"<<std::endl;
          }
       } 
       else
       {
        not_done = this->do_organize(); 
        steps_taken++;
       }
       
      }
     
  return steps_taken;    
}
bool JITD::do_organize()
{
  //std::cout<<"calling do organize"<<std::endl;
  @ctx.policyImplementation.doOrganize(ctx, "(*(this->jitd_root))")
}
///////////////////// Set/PQ populate ///////////////////// 

void JITD::SetPqErase(std::shared_ptr<JITDNode> * node_handle)
{
  std::shared_ptr<JITDNode> node_ptr = std::atomic_load((node_handle));
  switch(node_ptr->type){
    @for(node <- ctx.definition.nodes) {
      case @node.enumName : {
          @{RenderPattern.SetPopulate(ctx,ctx.policy.rule,"erase","node_handle",s"${node.name}",s"${node.enumName}");}
          @{RenderPattern.PQPopulate(ctx,ctx.policy.rule,"erase","node_handle",s"${node.name}",s"${node.enumName}");}
          };break;
        }
      }
}
void JITD::SetPqAdd(std::shared_ptr<JITDNode> * node_handle)
{
  std::shared_ptr<JITDNode> node_ptr = std::atomic_load((node_handle));
  switch(node_ptr->type){
    @for(node <- ctx.definition.nodes) {
      case @node.enumName : {
          @{RenderPattern.SetPopulate(ctx,ctx.policy.rule,"emplace","node_handle",s"${node.name}",s"${node.enumName}");}
          @{RenderPattern.PQPopulate(ctx,ctx.policy.rule,"emplace","node_handle",s"${node.name}",s"${node.enumName}");}
          };break;
        }
      }
}
///////////////////// Debugging Utilities ///////////////////// 

std::shared_ptr<JITD> assemble_jitd(std::istream &in)
{
  std::string op, line;

  std::stack<std::shared_ptr<JITDNode>> node_stack;
  std::shared_ptr<JITDNode> jitd_root_handle;
  while(getline(in, line)){
    std::basic_istringstream<char> toks(line);
    int columns = 0;
    toks >> op;
    @for(node <- ctx.definition.nodes){
      if(op == "@node.name"){
        @for(field <- node.fields.reverse){

          // Construct a @field.name
          @ctx.cType(field.t) @field.name;
          @{ field.t match {
            case TRecord() => s""

            //case TArray(TRecord()) => s"load_records_from_file_ycsb(${field.name}, toks,columns);"
            case TArray(TRecord()) => s"load_records(${field.name}, toks);"

            case TNodeRef() => s"${field.name} = node_stack.top(); node_stack.pop();"

            case TKey() => s"${field.name} = load_key(toks);"

            case _ => "std::cout << \"Unsupported generator field type: "+field.t.toString+"\" << std::endl; exit(-1);"
          }}
        }

        // Assemble everything into a @node.name
        node_stack.emplace(new @{node.renderName}(@{node.fields.map { _.name }.mkString(", ")}));
      

      } else 
    }
    
    if(op == "Return")
    {
      return std::shared_ptr<JITD>(new JITD(std::shared_ptr<std::shared_ptr<JITDNode>>(new std::shared_ptr<JITDNode>(node_stack.top()))));
    }
    else {
      std::cerr << "Invalid assembly instruction '"<<op<<"'" << std::endl; 
      exit(-1); 
      return std::shared_ptr<JITD>();
    }
  }
  std::cerr << "Reached end of build with no Return" << std::endl; 
  exit(-1); 
}
void JITD::print_pq()
{

  
}
void JITD::check_pq()
{
  
    
   
    

}
void print_JITD_node_structure(std::shared_ptr<JITDNode> node, const std::string &prefix){ 

  switch(node->type){
    @for(node <- ctx.definition.nodes) {
      case @node.enumName : {
        @node.renderName *node_real = (@node.renderName *)node.get();
        std::cout << prefix << "@{node.name}[ "
        @{ node.fields.filter { _.t != TNodeRef() }
            .map { f => 
                "<< \"" + f.name + "=\" << " +
                ctx.printableValue("node_real->"+f.name, f.t) 
            }.mkString(" << \", \"") };

        @{  val children = node.fields.filter { _.t == TNodeRef() }
            if(children.size > 0){
              "std::cout << std::endl;\n"+
              children.map { f => 
                "print_JITD_node_structure(node_real->"+f.name+", prefix+std::string(\"  \"));\n"
              }.mkString+
              "std::cout << prefix;"
            } else { "" }
        } 
        std::cout << " ]" << std::endl;
        break;
      }
    }
  }
}
