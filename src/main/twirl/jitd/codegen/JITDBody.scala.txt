@import jitd.codegen._
@import jitd.spec._
@import jitd.rewrite._
@(ctx:Render, headerFile:String)

#include <stack>
#include <sstream>
#include "@headerFile"


///////////////////// Transform Definitions ///////////////////// 

@for(transform <- ctx.definition.transforms){
  void @{transform.name}(std::shared_ptr<JITDNode> &target){
    // Make sure that we hold a reference to the physical pointer
    std::shared_ptr<JITDNode> physicalLock = target;
    const JITDNode *from = physicalLock.get();

    // Check that the transform is valid (and extract fields)
    @{RenderPattern.test(ctx, transform.from, "from", "return;")}

    // Build the new root
    @{RenderPattern.build(ctx, transform.to, "to", 
      transform.unifiedInitializers(RenderPattern.varMapping(ctx, transform.from, "from")))}

    // (if relevant) any follow-up code
    @{ctx.statement(
        Inline(
          transform.body, 
          RenderPattern.varMapping(ctx, transform.from, "from")++
          RenderPattern.varMapping(ctx, transform.to, "to")
        )
      )}

    // and link the rewritten node back into the tree
    target = to;
  }
}

///////////////////// Accessor Definitions ///////////////////// 

@for( accessor <- ctx.definition.accessors ) {
  @{RenderAccessor.declaration(accessor, ctx, prefix = "JITD::")} {
    @{RenderAccessor.body(accessor, ctx)}
  }
}

///////////////////// Mutator Definitions ///////////////////// 

@for( mutator <- ctx.definition.mutators ) {
  @{RenderMutator.declaration(mutator, ctx, prefix = "JITD::")} {
    @{RenderPattern.build(ctx, mutator.rewrite, "new_root", 
        mutator.initializers ++ Map(
          "root" -> StructSubscript(Var("(*this)"), "root")
        ) ++ mutator.args.map { f => f.name -> Var(f.name) }.toMap
      )}
  }
}


///////////////////// Assemble JITD for Testing ///////////////////// 

std::shared_ptr<JITD> assemble_jitd(std::istream &in)
{
  std::string op, line;

  std::stack<std::shared_ptr<JITDNode>> node_stack;
  while(getline(in, line)){
    std::basic_istringstream<char> toks(line);
    toks >> op;

    @for(node <- ctx.definition.nodes){
      if(op == "@node.name"){
        @for(field <- node.fields){

          // Construct a @field.name
          @ctx.cType(field.t) @field.name;
          @{ field.t match {
            
            case TArray(TRecord()) => s"load_records(${field.name}, toks);"
            
            case TNode() => s"${field.name} = node_stack.top(); node_stack.pop();"

            case TKey() => s"${field.name} = load_key(toks);"

            case _ => "std::cout << \"Unsupported generator field type: "+field.t.toString+"\" << std::endl; exit(-1);"
          }}
        }

        // Assemble everything into a @node.name
        node_stack.emplace(new @{node.renderName}(@{node.fields.map { _.name }.mkString(", ")}));

      } else 
    }
    if(op == "Return"){
      return std::shared_ptr<JITD>(new JITD(node_stack.top()));
    } else {
      std::cout << "Invalid assembly instruction '"<<op<<"'" << std::endl; 
      exit(-1); 
    }
  }
}