@import jitd.codegen._
@import jitd.spec._
@import jitd.rewrite._
@import jitd.Debug
@(ctx:Render, headerFile:String)

#include <stack>
#include <sstream>
#include "runtime.hpp"
#include "@headerFile"


//#define JITD_DEBUG_POLICY true;
//std::shared_ptr<JITDNode> * rootHandleRef;


///////////////////// Transform Definitions ///////////////////// 

@for(transform <- ctx.definition.transforms){
@RenderFunction.body(ctx, TransformToFunction(ctx.definition, transform,"JITD::"),false)
}

///////////////////// Accessor Definitions ///////////////////// 

@for( accessor <- ctx.definition.accessors ) {
@{RenderFunction.body(ctx, AccessorToFunction(ctx.definition, accessor, "jitd_accessor_"),false)}
}

///////////////////// Mutator Definitions ///////////////////// 

@for( mutator <- ctx.definition.mutators ) {
@{RenderFunction.body(ctx, MutatorToFunction(ctx.definition, mutator, "JITD::"),false)}
@{RenderFunction.body(ctx, MutatorToFunctionAfter(ctx.definition, mutator, "JITD::after_"),true)}

}
///////////////////// OnMatch Transforms /////////////////////

@ctx.policyImplementation.onMatchPattern(ctx,ctx.policy.rule)
///////////////////// Policy Implementation ///////////////////// 

@ctx.policyImplementation.utilityFunctions(ctx)


int JITD::organize_wait()
{
  
    int t = 0;
   
    bool not_done = true;
    while(true)
    {

      if(this->work_queue.empty() && not_done == true)
      {
        
        not_done = this->do_organize();
        t++;
        //std::cout<<"JITD_PRINT: "<<not_done<<std::endl;
        //this->print_debug();
        //this->check_view();
        //this->print_map();
        
        
      }
      else
      {
        mutatorCqElement pop_mce;
        
        this->work_queue.pop(pop_mce);
        if(pop_mce.flag == EXIT)
        {
          #ifdef TRANSFORM_COUNT
            this->times_transforms_called();
          #endif
          return t;
        }
        @for( mutator <- ctx.definition.mutators ){
        else if(pop_mce.flag == FLAG_@mutator.name)
        {
          this->after_@{mutator.name}(pop_mce.element);
          not_done = true;
          //std::cout<<"AFTER_@{mutator.name}_PRINT: "<<not_done<<std::endl;
          //this->print_debug();
          //this->check_view();
          //this->print_map();
          
        }
        }
        else
        {
          std::cerr<<"Invalid Mutator Operation"<<std::endl;
          exit(-1);
        }
        
      }
      
    
    }   
    
   
       
  return t;
}
void JITD::initialize_struts_view(std::shared_ptr<JITDNode>* node,std::shared_ptr<JITDNode>* parent)
{
    std::shared_ptr<JITDNode> target_root_lock;
    #ifdef ATOMIC_LOAD
    target_root_lock = std::atomic_load((node));
    #endif
    #ifdef ATOMIC_LOAD_CONSUME
    target_root_lock = std::atomic_load_explicit(node,std::memory_order_consume);
    #endif
    #ifdef ATOMIC_LOAD_ACQUIRE
    target_root_lock = std::atomic_load_explicit(node,std::memory_order_acquire);
    #endif
  //std::shared_ptr<JITDNode> target_root_lock = std::atomic_load((node));
  this->childParentMap.emplace(node,parent);
  viewAdd(node);
  switch(target_root_lock->type)
  {
    @for(node <- ctx.definition.nodes) {
      case @node.enumName : {
      @node.renderName *node_real = (@node.renderName *)target_root_lock.get();
        @{  val children = node.fields.filter { _.t == TNodeRef() }
            if(children.size > 0){
              
              children.map { f => 
                "initialize_struts_view(&(node_real->"+f.name+"),node);\n"
              }.mkString
            } else { "" }
        } 
        break;      
      }

    }

  }
}
/*
void JITD::initialize_struts(std::shared_ptr<JITDNode>* node,std::shared_ptr<JITDNode>* parent)
{
    std::shared_ptr<JITDNode> target_root_lock;
    #ifdef ATOMIC_LOAD
    target_root_lock = std::atomic_load((node));
    #endif
    #ifdef ATOMIC_LOAD_CONSUME
    target_root_lock = std::atomic_load_explicit(node,std::memory_order_consume);
    #endif
    #ifdef ATOMIC_LOAD_ACQUIRE
    target_root_lock = std::atomic_load_explicit(node,std::memory_order_acquire);
    #endif
  //std::shared_ptr<JITDNode> target_root_lock = std::atomic_load((node));
  this->childParentMap.emplace(node,parent);
  viewAdd(node);
  switch(target_root_lock->type)
  {
    @for(node <- ctx.definition.nodes) {
      case @node.enumName : {
      @{RenderPattern.SetPopulate(ctx,ctx.policy.rule,"emplace","node",s"${node.name}",s"${node.enumName}");}
      @{RenderPattern.PQPopulate(ctx,ctx.policy.rule,"emplace","node",s"${node.name}",s"${node.enumName}");}
      @node.renderName *node_real = (@node.renderName *)target_root_lock.get();
        @{  val children = node.fields.filter { _.t == TNodeRef() }
            if(children.size > 0){
              
              children.map { f => 
                "initialize_struts(&(node_real->"+f.name+"),node);\n"
              }.mkString
            } else { "" }
        } 
        break;      
      }

    }

  }

}
*/
bool JITD::do_organize()
{
  
  @ctx.policyImplementation.doOrganize(ctx, "(*(this->jitd_root))")
}
///////////////////// Set/PQ/View populate ///////////////////// 
/*
void JITD::SetPqErase(std::shared_ptr<JITDNode> * node_handle)
{
  #ifdef DEBUG
    assert(node_handle!=NULL);
  #endif
    std::shared_ptr<JITDNode> node_ptr;
    #ifdef ATOMIC_LOAD
    node_ptr = std::atomic_load((node_handle));
    #endif
    #ifdef ATOMIC_LOAD_CONSUME
    node_ptr = std::atomic_load_explicit(node_handle,std::memory_order_consume);
    #endif
    #ifdef ATOMIC_LOAD_ACQUIRE
    node_ptr = std::atomic_load_explicit(node_handle,std::memory_order_acquire);
    #endif
  //std::shared_ptr<JITDNode> node_ptr = std::atomic_load((node_handle));
   #ifdef DEBUG
    assert(node_ptr!=NULL);
  #endif
  switch((node_ptr)->type){
    @for(node <- ctx.definition.nodes) {
      case @node.enumName : {
          @{RenderPattern.SetPopulate(ctx,ctx.policy.rule,"erase","node_handle",s"${node.name}",s"${node.enumName}");}
          @{RenderPattern.PQPopulate(ctx,ctx.policy.rule,"erase","node_handle",s"${node.name}",s"${node.enumName}");}
          };break;
        }
        default:{std::cerr << "Unhandled Node Type in get" << std::endl;
        exit(-1);};break;
      }
      #ifdef DEBUG
        //check_pq();
      #endif 
}
void JITD::SetPqAdd(std::shared_ptr<JITDNode> * node_handle)
{
 #ifdef DEBUG
    assert(node_handle!=NULL);
  #endif
  std::shared_ptr<JITDNode> node_ptr;
    #ifdef ATOMIC_LOAD
    node_ptr = std::atomic_load((node_handle));
    #endif
    #ifdef ATOMIC_LOAD_CONSUME
    node_ptr = std::atomic_load_explicit(node_handle,std::memory_order_consume);
    #endif
    #ifdef ATOMIC_LOAD_ACQUIRE
    node_ptr = std::atomic_load_explicit(node_handle,std::memory_order_acquire);
    #endif
  //std::shared_ptr<JITDNode> node_ptr = std::atomic_load((node_handle));
   #ifdef DEBUG
    assert(node_ptr!=NULL);
  #endif
  switch((node_ptr)->type){
    @for(node <- ctx.definition.nodes) {
      case @node.enumName : {
          @{RenderPattern.SetPopulate(ctx,ctx.policy.rule,"emplace","node_handle",s"${node.name}",s"${node.enumName}");}
          @{RenderPattern.PQPopulate(ctx,ctx.policy.rule,"emplace","node_handle",s"${node.name}",s"${node.enumName}");}
          };break;
        }
      default:{std::cerr << "Unhandled Node Type in get" << std::endl;
      exit(-1);};break;
      }
      #ifdef DEBUG
        //check_pq();
      #endif  
}*/
void JITD::viewAdd(std::shared_ptr<JITDNode>* node_handle)
{
  if(node_handle == NULL){return;}
  bool matched = false;
  std::shared_ptr<JITDNode> node_ptr;
    #ifdef ATOMIC_LOAD
    node_ptr = std::atomic_load((node_handle));
    #endif
    #ifdef ATOMIC_LOAD_CONSUME
    node_ptr = std::atomic_load_explicit(node_handle,std::memory_order_consume);
    #endif
    #ifdef ATOMIC_LOAD_ACQUIRE
    node_ptr = std::atomic_load_explicit(node_handle,std::memory_order_acquire);
    #endif
  //std::shared_ptr<JITDNode> node_ptr = std::atomic_load((node_handle));
  switch((node_ptr)->type){
    @for(node <- ctx.definition.nodes) {
      case @node.enumName : {
        @{RenderPattern.ViewCall(ctx,ctx.policy.rule,s"${node.name}","emplace","node_handle");}
        break;
      }

    }

  }

}
void JITD::viewErase(std::shared_ptr<JITDNode>* node_handle)
{
  if(node_handle == NULL){return;}
  bool matched = false;
  std::shared_ptr<JITDNode> node_ptr;
    #ifdef ATOMIC_LOAD
    node_ptr = std::atomic_load((node_handle));
    #endif
    #ifdef ATOMIC_LOAD_CONSUME
    node_ptr = std::atomic_load_explicit(node_handle,std::memory_order_consume);
    #endif
    #ifdef ATOMIC_LOAD_ACQUIRE
    node_ptr = std::atomic_load_explicit(node_handle,std::memory_order_acquire);
    #endif
  //std::shared_ptr<JITDNode> node_ptr = std::atomic_load((node_handle));
  switch((node_ptr)->type){
    @for(node <- ctx.definition.nodes) {
      case @node.enumName : {
        @{RenderPattern.ViewCall(ctx,ctx.policy.rule,s"${node.name}","erase","node_handle");}
        break;
      
      }

    }

  }
  
}
std::shared_ptr<JITDNode> * JITD::getParent(std::shared_ptr<JITDNode> * &target)
{
  std::unordered_multimap <std::shared_ptr<JITDNode> *, std::shared_ptr<JITDNode> *> :: iterator iter; 
  iter = this->childParentMap.find(target);
  if(iter!=childParentMap.end())
  {
    //parent = (iter->second);
    return iter->second;
  }
  else
  {
    //parent = NULL;
    return NULL;
  }
  
}
void JITD::fixMap(std::shared_ptr<JITDNode>* node_handle,std::shared_ptr<JITDNode>* parent)
{
  std::shared_ptr<JITDNode> node_ptr;
    #ifdef ATOMIC_LOAD
    node_ptr = std::atomic_load((node_handle));
    #endif
    #ifdef ATOMIC_LOAD_CONSUME
    node_ptr = std::atomic_load_explicit(node_handle,std::memory_order_consume);
    #endif
    #ifdef ATOMIC_LOAD_ACQUIRE
    node_ptr = std::atomic_load_explicit(node_handle,std::memory_order_acquire);
    #endif
  //std::shared_ptr<JITDNode> node_ptr = std::atomic_load((node_handle));
  switch((node_ptr)->type){
  @for(node <- ctx.definition.nodes) {
    case @node.enumName : {
      @node.renderName *node_real = (@node.renderName *)node_ptr.get();
      std::unordered_multimap <std::shared_ptr<JITDNode> *, std::shared_ptr<JITDNode> *> :: iterator iter;

      @{  val children = node.fields.filter { _.t == TNodeRef() }
            
              
              children.map { f => 
                "iter = this->childParentMap.find(&(node_real->"+f.name+"));\n"+ 
                "if(iter!=this->childParentMap.end()){\n"+
                "iter->second = parent;\n"+
                "}\n"
              }.mkString
           
        }
      break;
    }

  }

  }
}

///////////////////// Debugging Utilities ///////////////////// 
void JITD::times_transforms_called()
{
  @for( transform <- ctx.definition.transforms ){
    std::cout<<"The transform @{transform.name} was called "<< @{transform.name}_count<<" times"<<std::endl;
  }
}
std::shared_ptr<JITD> assemble_jitd(std::istream &in)
{
  std::string op, line;

  std::stack<std::shared_ptr<JITDNode>> node_stack;
  std::shared_ptr<JITDNode> jitd_root_handle;
  while(getline(in, line)){
    std::basic_istringstream<char> toks(line);
    int columns = 0;
    toks >> op;
    @for(node <- ctx.definition.nodes){
      if(op == "@node.name"){
        @for(field <- node.fields.reverse){

          // Construct a @field.name
          @ctx.cType(field.t) @field.name;
          @{ field.t match {
            case TRecord() => s""

            //case TArray(TRecord()) => s"load_records_from_file_ycsb(${field.name}, toks,columns);"
            case TArray(TRecord()) => s"load_records(${field.name}, toks);"

            case TNodeRef() => s"${field.name} = node_stack.top(); node_stack.pop();"

            case TKey() => s"${field.name} = load_key(toks);"

            case _ => "std::cout << \"Unsupported generator field type: "+field.t.toString+"\" << std::endl; exit(-1);"
          }}
        }

        // Assemble everything into a @node.name
        node_stack.emplace(new @{node.renderName}(@{node.fields.map { _.name }.mkString(", ")}));
      

      } else 
    }
    
    if(op == "Return")
    {
      return std::shared_ptr<JITD>(new JITD(std::shared_ptr<std::shared_ptr<JITDNode>>(std::make_shared<std::shared_ptr<JITDNode>>(std::shared_ptr<JITDNode>(node_stack.top())))));
    }
    else {
      std::cerr << "Invalid assembly instruction '"<<op<<"'" << std::endl; 
      exit(-1); 
      return std::shared_ptr<JITD>();
    }
  }
  std::cerr << "Reached end of build with no Return" << std::endl; 
  exit(-1); 
}


void JITD:: check_view()
{
      std::set<std::shared_ptr<JITDNode> *>::iterator it;
      @for(transform <- ctx.definition.transforms){
        std::cout<<"SIZE OF @{transform.name} View"<<@{transform.name}_View.size()<<"."<<std::endl;
        for(it = this->@{transform.name}_View.begin();it!=this->@{transform.name}_View.end();++it)
        {
        
          

          std::shared_ptr<JITDNode> * curr = *it;
          std::cout<<"Address of shared_ptr: "<<*curr<<std::endl;

          
          

        }
      }
      
}
void JITD::print_pq()
{

  
}

void JITD::print_map()
{
  std::unordered_multimap <std::shared_ptr<JITDNode> *, std::shared_ptr<JITDNode> *> :: iterator itr; 
  for (itr = childParentMap.begin(); itr != childParentMap.end(); ++itr) 
    { 
        if(itr->first != NULL)
        {
          std::shared_ptr<JITDNode> node = *(itr->first);
          if(node!=NULL)
          {
            switch(node->type)
            {
              @for(node <- ctx.definition.nodes) {
                case @node.enumName : {
                  @node.renderName *node_real = (@node.renderName *)node.get();
                  std::cout <<itr->first<< ":@{node.name}(addr:"<<node_real<<")-> ";
                  break;
                }
              }
            }
          }
          else
          {
            std::cout<<  '\t' << "node is NULL" << '\n';
          }
        
        }
        else
        {
            std::cout<<  '\t' << "iter->first is NULL" << '\n';
        }
        if(itr->second != NULL)
        {
          std::shared_ptr<JITDNode> parent = *(itr->second);
          if(parent!=NULL)
          {
            switch(parent->type)
            {
              @for(node <- ctx.definition.nodes) {
                case @node.enumName : {
                  @node.renderName *parent_real = (@node.renderName *)parent.get();
                  std::cout <<itr->second<<'\t'<< ":@{node.name}(addr:"<<parent_real<<") "<<'\n';
                  break;
                }
              }
            }
          }
          else
          {
            std::cout<<  '\t' << "parent is NULL" << '\n';
          }
          
        }
        else
        {
          std::cout<<  '\t' << "iter->second is NULL" << '\n'; 
        }
    } 
    std::cout << std::endl; 
}

void print_JITD_node_structure(std::shared_ptr<JITDNode> node, const std::string &prefix){ 

  switch(node->type){
    @for(node <- ctx.definition.nodes) {
      case @node.enumName : {
        @node.renderName *node_real = (@node.renderName *)node.get();
        std::cout << prefix << "@{node.name}(addr:"<<node_real<<")[ "
        @{ node.fields.filter { _.t != TNodeRef() }
            .map { f => 
                "<< \"" + f.name + "=\" << " +
                ctx.printableValue("node_real->"+f.name, f.t) 
            }.mkString(" << \", \"") };

        @{  val children = node.fields.filter { _.t == TNodeRef() }
            if(children.size > 0){
              "std::cout << std::endl;\n"+
              children.map { f => 
                "print_JITD_node_structure(node_real->"+f.name+", prefix+std::string(\"  \"));\n"
              }.mkString+
              "std::cout << prefix;"
            } else { "" }
        } 
        std::cout << " ]" << std::endl;
        break;
      }
    }
  }
}
void jitd_get_depth(std::shared_ptr<JITDNode> node, int depth, int &maxdepth)
{
  if(node != NULL)
  {
  switch(node->type){
  @for(node <- ctx.definition.nodes) {
    case @node.enumName : {
        @node.renderName *node_real = (@node.renderName *)node.get();
        @{  val children = node.fields.filter { _.t == TNodeRef() }
            if(children.size > 0){
              children.map { f => 
                  if(f.name == "rhs")
                  {
                    "jitd_get_depth(node_real->"+f.name+",depth,maxdepth);\n"

                  }
                  else
                  {
                    "jitd_get_depth(node_real->"+f.name+",++depth,maxdepth);\n"+
                    "if(depth > maxdepth){\n"+
                    "maxdepth = depth;\n"+
                    "}\n"

                  }
                
              }.mkString
            } else { "" }
        }
        break; 
      }
    }

  }
 } 
}
void print_JITD_node_structure_viz(std::shared_ptr<JITDNode> node,std::shared_ptr<JITDNode> parent){ 

  switch(node->type){
    @for(node <- ctx.definition.nodes) {
      case @node.enumName : {
        @node.renderName *node_real = (@node.renderName *)node.get();
        switch(parent->type){
          @for(node <- ctx.definition.nodes) {
          case @node.enumName : {
              std::cout << "@{node.name}(addr:"<<node_real<<")[] -> ";

          break;}

          }
        }

        std::cout << "@{node.name}(addr:"<<node_real<<")[] "<<std::endl;
        

        @{  val children = node.fields.filter { _.t == TNodeRef() }
            if(children.size > 0){
              "std::cout << std::endl;\n"+
              children.map { f => 
                "print_JITD_node_structure_viz(node_real->"+f.name+",node);\n"
              }.mkString
            } else { "" }
        } 
        //std::cout << " ]" << std::endl;
        break;
      }
    }
  }
}
