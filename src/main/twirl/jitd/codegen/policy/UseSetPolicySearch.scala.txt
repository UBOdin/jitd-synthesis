@import jitd.spec._
@import jitd.codegen._
@import jitd.rewrite.InlineVars
@import jitd.Debug
@(ctx:Render, transform:Transform, constraint:Expression, scoreFn:Expression)

  long JITD::searchFor@{transform.name}(          // Return the "best" score available 
    std::shared_ptr<JITDNode> * &targetHandleRef // Return value: The pointer with the "best" score
  ) {
  
    //std::cout<<"STARTING TRANSFORM@transform.name"<<std::endl;
    int count = 0;
    long best_score = -1;
    long curr_score = -1;
    if(!(this->@{RenderPattern.setGen(ctx, transform.from)}).empty())
    {
      
      std::set< std::shared_ptr<JITDNode> * >::iterator it;
      for(it = (this->@{RenderPattern.setGen(ctx, transform.from)}).begin(); it!=(this->@{RenderPattern.setGen(ctx, transform.from)}).end(); ++it)
      {
          #ifdef DEBUG
          assert(*it!=NULL);
          #endif
          /*
          std::shared_ptr<JITDNode> * pspjn = *it;
          
          #ifdef DEBUG
          assert(pspjn!=NULL);
          #endif

          std::shared_ptr<JITDNode> spjn = *pspjn;

          #ifdef DEBUG
          assert(spjn!=NULL);
          #endif
          
          JITDNode *iter_node = (spjn).get();
          */

           JITDNode *iter_node = (*it)->get();
          

           @{RenderPattern.test(ctx, transform.from, "iter_node", "continue;")}
          
           if(@{ctx.expression(InlineVars(constraint, 
            RenderPattern.varMapping(ctx, transform.from, "iter_node")++
            ctx.policy.varMapping
          ))}){
            best_score = @{ctx.expression(InlineVars(scoreFn, 
            RenderPattern.varMapping(ctx, transform.from, "iter_node")++
            ctx.policy.varMapping
          ))};
          }

          if(best_score>curr_score)
          {
            //std::cout<<"BESTSCORE: "<<best_score<<std::endl;
            curr_score = best_score;
            
            targetHandleRef = (*it);
            
          
      }
    }




}
    return best_score;
  
  }
