@import jitd.spec._
@import jitd.codegen._
@import jitd.rewrite.Inline
@(ctx:Render, transform:Transform, constraint:Expression, scoreFn:Expression)

  long searchFor@{transform.name}(          // Return the "best" score available
    const std::shared_ptr<JITDNode> &node,  // Pointer to the node we're currently examining
    std::shared_ptr<JITDNode> &target,      // Return value: The pointer with the "best" score
    const UpdateHandle &in_updater,         // Function to call to update the current node
    UpdateHandle &out_updater               // Return value: Function to call to update the best node
  ) {
    std::shared_ptr<JITDNode> lock = node;
    JITDNode *lock_raw = lock.get();

    long best_score = -1;
    long child_score = -1;
    std::shared_ptr<JITDNode> child_target;
    UpdateHandle child_updater;


    do {
      // std::cout << "  Testing @{transform.name} on: " << std::endl;
      // print_JITD_node_structure(node, std::string("    ")); std::cout << std::endl;

      @{RenderPattern.test(ctx, transform.from, "lock_raw", "break;")}

      // std::cout << "  Matched!" << std::endl << "  Checking constraint @constraint" << std::endl;

      if(@{ctx.expression(Inline(constraint, 
            RenderPattern.varMapping(ctx, transform.from, "lock_raw")++
            ctx.policy.varMapping
          ))}){
        best_score = @{ctx.expression(Inline(scoreFn, 
            RenderPattern.varMapping(ctx, transform.from, "lock_raw")++
            ctx.policy.varMapping
          ))};
        target = node;
        out_updater = in_updater;

      }
    } while(false);

    // std::cout << "  Best Score: " << best_score << "; Checking children..." << std::endl;

    switch(lock_raw->type){
      @for(node <- ctx.definition.nodes){
        case @{node.enumName}: {
          @{node.renderName} *real_node = (@{node.renderName} *)lock_raw;
          @for(field <- node.fields.filter { _.t == TNode() }){
            child_score = searchFor@{transform.name}(
              real_node->@{field.name}, 
              child_target,
              std::bind(
                &@{node.renderName}::update_@{field.name}_handle,
                real_node,
                std::placeholders::_1
              ),
              child_updater
            );
            if(child_score > best_score) { 
              target = child_target; 
              out_updater = child_updater; 
              best_score = child_score;
            }
          }
          break;
        }
      }
    }

    // std::cout << "  Overall Best Score: " << best_score << std::endl;

    return best_score;
  }
