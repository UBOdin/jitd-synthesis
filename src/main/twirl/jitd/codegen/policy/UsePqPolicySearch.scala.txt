@import jitd.spec._
@import jitd.codegen._
@import jitd.rewrite.InlineVars
@import jitd.Debug
@(ctx:Render, transform:Transform, constraint:Expression, scoreFn:Expression)

  long searchFor@{transform.name}(          // Return the "best" score available
    std::shared_ptr<JITDNode> * &node,  // Pointer to the node we're currently examining      
    std::shared_ptr<JITDNode> * &targetHandleRef // Return value: The pointer with the "best" score
  ) {
  

    int count = 0;
    long bestScore = -1;
    long curr_score = -1;
    
    if(!(@{RenderPattern.setPqGen(ctx, transform.from,"pq")}).empty())
    {
      std::set< std::shared_ptr<JITDNode> * >::iterator it;
      it = (@{RenderPattern.setPqGen(ctx, transform.from,"pq")}).begin();
      //std::cout<<"FOUND NODE"<<std::endl;
          JITDNode *iter_node = (*it)->get();
          //JITDNode *iter_node = (*it).get();
          
          @{RenderPattern.test(ctx, transform.from, "iter_node", "return -1;")}

          if(@{ctx.expression(InlineVars(constraint, 
            RenderPattern.varMapping(ctx, transform.from, "iter_node")++
            ctx.policy.varMapping
          ))}){
            bestScore = @{ctx.expression(InlineVars(scoreFn, 
            RenderPattern.varMapping(ctx, transform.from, "iter_node")++
            ctx.policy.varMapping
          ))};
          targetHandleRef = (*it);
          }

          //if(bestScore>curr_score)
          //{
           // curr_score = bestScore;
           // std::cout<<"CURR Score"<<curr_score<<std::endl;
            //targetHandleRef = (*it);
            
          //}
          /***Removing the candidate node from the PQ***/
          //@{RenderPattern.setPqGen(ctx, transform.from,"pq")}.erase(*it);
      
    }





    return bestScore;
  }
