@import jitd.spec._
@import jitd.codegen._
@import jitd.rewrite.InlineVars
@import jitd.Debug
@(ctx:Render, transform:Transform, constraint:Expression, scoreFn:Expression)

  long JITD::searchFor@{transform.name}(          // Return the "best" score available     
    std::shared_ptr<JITDNode> * &targetHandleRef // Return value: The pointer with the "best" score
  ) {
  

    int count = 0;
    long bestScore = -1;
    long curr_score = -1;
    timeval start1, end1, start2, end2;
    //gettimeofday(&start1,NULL);
    if(!(this->@{transform.name}_PQ).empty())
    {
    //gettimeofday(&end1,NULL);
    //float totalTime1 = (end1.tv_sec - start1.tv_sec) * 1000000.0 + (end1.tv_usec - start1.tv_usec);
    //@{transform.name}_empty.push_back(totalTime1);
      std::set< std::shared_ptr<JITDNode> * >::iterator it;
      //gettimeofday(&start2,NULL);
      it = (this->@{transform.name}_PQ).begin();
      //gettimeofday(&end2,NULL);
      //float totalTime2 = (end2.tv_sec - start2.tv_sec) * 1000000.0 + (end2.tv_usec - start2.tv_usec);
      //@{transform.name}_begin.push_back(totalTime2);
          JITDNode *iter_node = (*it)->get();
          
          
          @{RenderPattern.test(ctx, transform.from, "iter_node", "return -1;")}

          if(@{ctx.expression(InlineVars(constraint, 
            RenderPattern.varMapping(ctx, transform.from, "iter_node")++
            ctx.policy.varMapping
          ))}){
            bestScore = @{ctx.expression(InlineVars(scoreFn, 
            RenderPattern.varMapping(ctx, transform.from, "iter_node")++
            ctx.policy.varMapping
          ))};
          targetHandleRef = (*it);
          }

          
      
    }





    return bestScore;
  }
