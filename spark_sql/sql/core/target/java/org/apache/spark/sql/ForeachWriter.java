package org.apache.spark.sql;
/**
 * The abstract class for writing custom logic to process data generated by a query.
 * This is often used to write the output of a streaming query to arbitrary storage systems.
 * Any implementation of this base class will be used by Spark in the following way.
 * <p>
 * <ul>
 * <li>A single instance of this class is responsible of all the data generated by a single task
 *     in a query. In other words, one instance is responsible for processing one partition of the
 *     data generated in a distributed manner.
 * <p>
 * <li>Any implementation of this class must be serializable because each task will get a fresh
 *     serialized-deserialized copy of the provided object. Hence, it is strongly recommended that
 *     any initialization for writing data (e.g. opening a connection or starting a transaction)
 *     is done after the <code>open(...)</code> method has been called, which signifies that the task is
 *     ready to generate data.
 * <p>
 * <li>The lifecycle of the methods are as follows.
 * <p>
 *   <pre>
 *   For each partition with `partitionId`:
 *       For each batch/epoch of streaming data (if its streaming query) with `epochId`:
 *           Method `open(partitionId, epochId)` is called.
 *           If `open` returns true:
 *                For each row in the partition and batch/epoch, method `process(row)` is called.
 *           Method `close(errorOrNull)` is called with error (if any) seen while processing rows.
 *   </pre>
 * <p>
 * </ul>
 * <p>
 * Important points to note:
 * <ul>
 * <li>Spark doesn't guarantee same output for (partitionId, epochId), so deduplication
 *     cannot be achieved with (partitionId, epochId). e.g. source provides different number of
 *     partitions for some reason, Spark optimization changes number of partitions, etc.
 *     Refer SPARK-28650 for more details. If you need deduplication on output, try out
 *     <code>foreachBatch</code> instead.
 * <p>
 * <li>The <code>close()</code> method will be called if <code>open()</code> method returns successfully (irrespective
 *     of the return value), except if the JVM crashes in the middle.
 * </ul>
 * <p>
 * Scala example:
 * <pre><code>
 *   datasetOfString.writeStream.foreach(new ForeachWriter[String] {
 *
 *     def open(partitionId: Long, version: Long): Boolean = {
 *       // open connection
 *     }
 *
 *     def process(record: String) = {
 *       // write string to connection
 *     }
 *
 *     def close(errorOrNull: Throwable): Unit = {
 *       // close the connection
 *     }
 *   })
 * </code></pre>
 * <p>
 * Java example:
 * <pre><code>
 *  datasetOfString.writeStream().foreach(new ForeachWriter&lt;String&gt;() {
 *
 *    &#64;Override
 *    public boolean open(long partitionId, long version) {
 *      // open connection
 *    }
 *
 *    &#64;Override
 *    public void process(String value) {
 *      // write string to connection
 *    }
 *
 *    &#64;Override
 *    public void close(Throwable errorOrNull) {
 *      // close the connection
 *    }
 *  });
 * </code></pre>
 * <p>
 * @since 2.0.0
 */
public abstract class ForeachWriter<T extends java.lang.Object> implements scala.Serializable {
  // not preceding
  // TypeTree().setOriginal(TypeBoundsTree(TypeTree(), TypeTree()))
  public   ForeachWriter ()  { throw new RuntimeException(); }
  /**
   * Called when stopping to process one partition of new data in the executor side. This is
   * guaranteed to be called either <code>open</code> returns <code>true</code> or <code>false</code>. However,
   * <code>close</code> won't be called in the following cases:
   * <p>
   * <ul>
   * <li>JVM crashes without throwing a <code>Throwable</code></li>
   * <li><code>open</code> throws a <code>Throwable</code>.</li>
   * </ul>
   * <p>
   * @param errorOrNull the error thrown during processing data or null if there was no error.
   */
  public abstract  void close (java.lang.Throwable errorOrNull)  ;
  /**
   * Called when starting to process one partition of new data in the executor. See the class
   * docs for more information on how to use the <code>partitionId</code> and <code>epochId</code>.
   * <p>
   * @param partitionId the partition id.
   * @param epochId a unique id for data deduplication.
   * @return <code>true</code> if the corresponding partition and version id should be processed. <code>false</code>
   *         indicates the partition should be skipped.
   */
  public abstract  boolean open (long partitionId, long epochId)  ;
  /**
   * Called to process the data in the executor side. This method will be called only if <code>open</code>
   * returns <code>true</code>.
   * @param value (undocumented)
   */
  public abstract  void process (T value)  ;
}
